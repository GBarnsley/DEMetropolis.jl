var documenterSearchIndex = {"docs":
[{"location":"custom/#Customizing-your-sampler","page":"Customizing your sampler","title":"Customizing your sampler","text":"","category":"section"},{"location":"custom/#Custom-Stopping-Criteria","page":"Customizing your sampler","title":"Custom Stopping Criteria","text":"","category":"section"},{"location":"custom/#Custom-Diagnostic-Checks","page":"Customizing your sampler","title":"Custom Diagnostic Checks","text":"","category":"section"},{"location":"custom/#Custom-Proposal-Distributions","page":"Customizing your sampler","title":"Custom Proposal Distributions","text":"","category":"section"},{"location":"#DEMetropolis-Documentation","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"","category":"section"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"Tools for sampling from log-densities using differential evolution algorithms.","category":"page"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"See Sampling from multimodal distributions and Customizing your sampler to get started.","category":"page"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"This package is built upon LogDensityProblems.jl so log-densities should be constructed using that package, and can be used with TransformVariables.jl to control the parameter space.","category":"page"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"The other key dependency is Distributions.jl. Almost every parameter in proposals given here (see Proposal Distributions) are defined via customizable univariate distributions. Values that are fixed are specified via a Dirac distribution, though in the API these can be specified with any real value. As a warning there are minimal checks on the given distributions, it is up to the user to ensure that they are suitable for the given parameter, i.e. there is nothing stopping you from having the noise term in the deMC proposal be centred around 100 instead of 0, or have the distribution for a probability be > 1. Distributions can optionally be used to define your log-density, as in the examples given here. ","category":"page"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"As far as I am aware, there is one other package that implements differential evolution MCMC in Julia, DifferentialEvolutionMCMC.jl. I opted to implement my own version as I wanted a more flexible API and the subsampling scheme from DREAM. That's not to discredit DifferentialEvolutionMCMC.jl, it has many features this package does not, such as being able to work on optimization problems and parameter blocking.","category":"page"},{"location":"#Next-Steps","page":"DEMetropolis Documentation","title":"Next Steps","text":"","category":"section"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"A few plans for this package, feel free to suggest features or improvements via issues:","category":"page"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"Implement multi-try and delayed rejection DREAM, I avoided these so far since I have been using these samplers for costly log-densities with relatively few parameters, such as one that solve an ODE.\nIntegrate with AbstractMCMC and MCMCChains, potentially not worth the cost since parrallelism in a deMCMC is within chains rather than across chains.","category":"page"},{"location":"#Contents","page":"DEMetropolis Documentation","title":"Contents","text":"","category":"section"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"","category":"page"},{"location":"#Functions","page":"DEMetropolis Documentation","title":"Functions","text":"","category":"section"},{"location":"#Implemented-Sampling-Schemes","page":"DEMetropolis Documentation","title":"Implemented Sampling Schemes","text":"","category":"section"},{"location":"#DEMetropolis.deMC","page":"DEMetropolis Documentation","title":"DEMetropolis.deMC","text":"Run the Differential Evolution Markov Chain (DE-MC) sampler proposed by ter Braak (2006)\n\nThis sampler uses the de_update step. It can optionally switch between two γ values (γ₁ and γ₂) with probability p_γ₂. This is so that the sampler can occasionally move between modes, by having γ₂ = 1 while γ₁ remains the optimal value based on the dimension of the problem.\n\nThis algorithm varies slightly from the original. Updates within a population occur on the previous position of that population. i.e. if chain 1 has been updated (a₁ → a₂) and chain 2 picks chain 1 to update from, then the value of chain 1 used by chain 2 is the pre-update version of chain 1 (a₁). This change allows the algorithm to be easily parallelised.\n\nSee doi.org/10.1007/s11222-006-8769-1 for more information on sampler.\n\nArguments\n\nld: The log-density function to sample from, intended to be a LogDensityProblem.\nn_its: The number of sampling iterations per chain.\n\nKeyword Arguments\n\nn_burnin: Number of burn-in iterations. Defaults to n_its * 5.\nn_chains: Number of chains. Defaults to dimension(ld) * 2.\ninitial_state: Initial states for the chains. Defaults to randn(rng, n_chains, dimension(ld)).\nmemory: Use memory-based sampling (true) or memoryless (false). Defaults to false.\nsave_burnt: Save burn-in samples. Defaults to false.\nparallel: Run chains in parallel. Defaults to false.\nrng: Random number generator. Defaults to default_rng().\ndiagnostic_checks: Diagnostic checks to run during burn-in. Defaults to nothing.\ncheck_epochs: Splits n_burnin into check_epochs + 1 epochs and applies the diagnostic checks at the end of each epoch, other than the final epoch. Defaults to 1. \nthin: Thinning interval. Defaults to 1.\nγ₁: Primary scaling factor for DE update. Defaults to 2.38 / sqrt(2 * dim).\nγ₂: Secondary scaling factor for DE update. Defaults to 1.0.\np_γ₂: Probability of using γ₂. Defaults to 0.1.\nβ: Noise distribution for DE update. Defaults to Uniform(-1e-4, 1e-4).\n\nReturns\n\nA named tuple containing the samples, sampler scheme, and potentially burn-in samples.\n\nExample\n\njulia> deMC(ld, 1000; n_chains = 10)\n\nSee also composite_sampler, deMCzs, DREAM.\n\n\n\n\n\n","category":"function"},{"location":"#DEMetropolis.deMCzs","page":"DEMetropolis Documentation","title":"DEMetropolis.deMCzs","text":"Run the Differential Evolution Markov Chain with snooker update and historic sampling (DE-MCzs) sampler proposed by ter Braak and Vrugt (2008).\n\nThis sampler runs until a stopping_criteria (default: Rhat of the last 50% of the chains is <1.2) is met. The sampler can occasionally propose snooker updates which can sample areas away from the current chains. Combined with the adaptive memory-based sampling this sampler can efficiently sample from a problem where n_chains < the dimension of the problem.\n\nSee: doi.org/10.1007/s11222-008-9104-9 for more information\n\nArguments\n\nld: The log-density function to sample from, intended to be a LogDensityProblem.\nepoch_size: The number of saved iterations per chain per epoch.\n\nKeyword Arguments\n\nwarmup_epochs: Number of warm-up epochs. Defaults to 5.\nepoch_limit: Maximum number of sampling epochs. Defaults to 20.\nn_chains: Number of chains. Defaults to dimension(ld) * 2.\nN₀: Size of the initial population (must be >= nchains + 3). Defaults to `nchains * 2`.\ninitial_state: Initial population state. Defaults to randn(rng, N₀, dimension(ld)).\nmemory: Use memory based sampling? Defaults to true.\nsave_burnt: Save warm-up samples. Defaults to true.\nparallel: Run chains in parallel with multithreading. Defaults to false.\nrng: Random number generator. Defaults to default_rng().\ndiagnostic_checks: Diagnostic checks during warm-up. Defaults to nothing.\nstopping_criteria: Criterion to stop sampling. Defaults to R̂_stopping_criteria().\nγ: Scaling factor for the DE update. Defaults to 2.38 / sqrt(2 * dim).\nγₛ: Scaling factor for the Snooker update. Defaults to 2.38 / sqrt(2).\np_snooker: Probability of using the Snooker update. Defaults to 0.1.\nβ: Noise distribution for DE update. Defaults to Uniform(-1e-4, 1e-4).\nthin: Thinning interval. Defaults to 10.\n\nReturns\n\nA named tuple containing the samples, sampler scheme, and potentially burn-in samples.\n\nExample\n\njulia> deMCzs(ld, 1000; n_chains = 3)\n\nSee also composite_sampler, deMC, DREAM.\n\n\n\n\n\n","category":"function"},{"location":"#DEMetropolis.DREAM","page":"DEMetropolis Documentation","title":"DEMetropolis.DREAM","text":"Run the Differential Evolution Adaptive Metropolis (DREAM) sampler\n\nThis sampler runs until a stopping_criteria (default: Rhat of the last 50% of the chains is <1.2) is met. The sampler uses subspace_sampling, where the cross-over probability is adapted during the burn-in period. It can optionally switch between two γ values, so that γ₁ can be the optimal value (based on sampled parameters) and γ₂ can be some fixed value (i.e. 1) so that the sampler can switch modes. This sampler also checks for outlier chains (where the mean log-density falls outside the IQR) and replaces then with the position of the chain with the highest log-density. This step breaks detailed balance its not performed in the last epoch of the warm-up period.\n\nSetting memory = true makes this the DREAMz sampler\n\nSee doi.org/10.1515/IJNSNS.2009.10.3.273 for more info.\n\nArguments\n\nld: The log-density function to sample from, intended to be a LogDensityProblem.\nepoch_size: The number of saved iterations per chain per epoch.\n\nKeyword Arguments\n\nwarmup_epochs: Number of warm-up epochs. Defaults to 5. Crossover probabilities are adapted in this period.\nepoch_limit: Maximum number of sampling epochs. Defaults to 20.\nn_chains: Number of chains. Defaults to dimension(ld) * 2.\nN₀: Size of the initial population (must be >= nchains). Defaults to `nchains. Only the firstn_chainswill be used ifmemory = false`.\ninitial_state: Initial population state. Defaults to randn(rng, N₀, dimension(ld)).\nmemory: Use memory-based sampling (true) or memoryless (false). Defaults to false.\nsave_burnt: Save warm-up samples. Defaults to true.\nparallel: Run chains in parallel. Defaults to false.\nrng: Random number generator. Defaults to default_rng().\ndiagnostic_checks: Diagnostic checks during warm-up. Defaults to [ld_check()].\nstopping_criteria: Criterion to stop sampling. Defaults to R̂_stopping_criteria().\nγ₁: Primary scaling factor for subspace update. Defaults to nothing (uses 2.38 / sqrt(2 * δ * d)). Can also be a Real value.\nγ₂: Secondary scaling factor for subspace update. Defaults to 1.0. Can also be a Real value\np_γ₂: Probability of using γ₂. Defaults to 0.2.\nn_cr: Number of crossover probabilities to adapt if cr₁/cr₂ are nothing. Defaults to 3.\ncr₁: Crossover probability distribution/value for γ₁. Defaults to nothing (adaptive). Can also be a Real value (<1) or a Distributions.UnivariateDistribution, in either case it is not adapted.\ncr₂: Crossover probability distribution/value for γ₂. See above.\nϵ: Additive noise distribution. Defaults to Uniform(-1e-4, 1e-4).\ne: Multiplicative noise distribution. Defaults to Normal(0.0, 1e-2).\nδ: Number of difference vectors distribution. Defaults to DiscreteUniform(1, 3).\nthin: Thinning interval. Defaults to 1.\n\nReturns\n\nA named tuple containing the samples, sampler scheme, and potentially burn-in samples.\n\nExample\n\njulia> DREAM(ld, 1000; n_chains = 10)\n\nSee also composite_sampler, deMC, deMCzs.\n\n\n\n\n\n","category":"function"},{"location":"#Tools-for-setting-up-your-own-sampler","page":"DEMetropolis Documentation","title":"Tools for setting up your own sampler","text":"","category":"section"},{"location":"#DEMetropolis.setup_sampler_scheme","page":"DEMetropolis Documentation","title":"DEMetropolis.setup_sampler_scheme","text":"Create a sampler scheme defining the update steps to be used in composite_sampler.\n\nThe update used in each iteration for each chain is randomly selected from the updates given here.\n\nArguments\n\nupdates...: One or more update_struct objects (e.g., created by setup_de_update, setup_snooker_update, setup_subspace_sampling or your own custom sampler).\n\nKeyword Arguments\n\nw: A vector of weights corresponding to each update step. If nothing, updates are chosen with equal probability. Weights must be non-negative.\n\nExamples\n\n# only snooker updates\njulia> setup_sampler_scheme(setup_snooker_update())\n\n# DE and Snooker\njulia> setup_sampler_scheme(setup_snooker_update(), setup_de_update())\n\n# With weights, snookers 10% of the time\njulia> setup_sampler_scheme(setup_snooker_update(), setup_de_update(), w = [0.9, 0.1])\n\n\n\n\n\n","category":"function"},{"location":"#DEMetropolis.composite_sampler","page":"DEMetropolis Documentation","title":"DEMetropolis.composite_sampler","text":"Run a composite MCMC sampler for a fixed number of iterations.\n\nFor sampling with your own sampling scheme from setup_sampling_scheme\n\nArguments\n\nld: The log-density function to sample from, intended to be a LogDensityProblem.\nn_its: The desired number of samples per chain.\nn_chains: The number of chains to run.\nmemory: Boolean indicating whether to sample from historic values instead sampling from current chains.\ninitial_state: An array containing the initial states for the chains and the initial population if memory=true.\nsampler_scheme: A sampler_scheme_struct defining the update steps to use.\n\nKeyword Arguments\n\nthin: Thinning interval for storing samples. Defaults to 1. If using memory this also effects which samples are added to the memory.\nsave_burnt: Boolean indicating whether to save burn-in samples. Defaults to false. Does not save thinned samples\nrng: Random number generator. Defaults to default_rng().\nn_burnin: Number of burn-in iterations. Defaults to n_its * 5. Any adaptions occur over this period.\nparallel: Boolean indicating whether to run chains in parallel using multithreading. Defaults to false.\ndiagnostic_checks: A vector of diagnostic_check_struct to run during burn-in. Defaults to nothing.\ncheck_epochs: Splits n_burnin into check_epochs + 1 epochs and applies the diagnostic checks at the end of each epoch, other than the final epoch. Defaults to 1. \n\nReturns\n\nA named tuple containing the samples, sampler scheme, and potentially burn-in samples.\n\nExample\n\n# DE and Snooker sample scheme with memory\njulia> composite_sampler(\n    ld, 1000, 10, true, initial_state, setup_sampler_scheme(setup_snooker_update(), setup_de_update())\n)\n\nSee also deMC, deMCzs, DREAM.\n\n\n\n\n\nRun a composite MCMC sampler until a stopping criterion is met.\n\nFor sampling with your own sampling scheme from setup_sampling_scheme.\n\nArguments\n\nld: The log-density function to sample from, intended to be a LogDensityProblem.\nepoch_size: The number of saved iterations per chain per epoch.\nn_chains: The number of chains to run.\nmemory: Boolean indicating whether to sample from historic values instead sampling from current chains.\ninitial_state: An array containing the initial states for the chains and the initial population if memory==true.\nsampler_scheme: A sampler_scheme_struct defining the update steps to use.\nstopping_criteria: A stopping_criteria_struct defining when to stop sampling.\n\nKeyword Arguments\n\nthin: Thinning interval for storing samples. Defaults to 1. If using memory this also effects which samples are added to the memory.\nsave_burnt: Boolean indicating whether to save burn-in samples. Defaults to false. Does not save thinned samples.\nrng: Random number generator. Defaults to default_rng().\nwarmup_epochs: Number of warm-up epochs before we begin checking the stopping criteria. Defaults to 5. Samples from these epochs won't be included in the final sample. Sampler adaptation only occurs in this period.\nparallel: Boolean indicating whether to run chains in parallel using multithreading. Defaults to false.\nepoch_limit: Maximum number of sampling epochs to run. Defaults to 20.\ndiagnostic_checks: A vector of diagnostic_check_struct to run during warm-up. Defaults to nothing.\n\nReturns\n\nA named tuple containing the samples, sampler scheme, and potentially burn-in samples.\n\nExample\n\n# DE and Snooker sample scheme with memory until Rhat ≤ 1.05\njulia> composite_sampler(\n    ld, 1000, 10, true, initial_state, setup_sampler_scheme(setup_snooker_update(), setup_de_update()), R̂_stopping_criteria(1.05)\n)\n\nSee also deMC, deMCzs, DREAM.\n\n\n\n\n\n","category":"function"},{"location":"#Proposal-Distributions","page":"DEMetropolis Documentation","title":"Proposal Distributions","text":"","category":"section"},{"location":"#DEMetropolis.setup_de_update","page":"DEMetropolis Documentation","title":"DEMetropolis.setup_de_update","text":"Set up a Differential Evolution (DE) update step.\n\nSee doi.org/10.1007/s11222-006-8769-1 for more information.\n\nArguments\n\nld: The log-density function (used to determine dimension if γ is not provided).\n\nKeyword Arguments\n\nγ: The scaling factor for the difference vector. Can be a Real, a Distributions.UnivariateDistribution, or nothing. If nothing, it defaults based on deterministic_γ and the problem dimension.\nβ: Distribution for the small noise term added to the proposal. Defaults to Uniform(-1e-4, 1e-4).\ndeterministic_γ: If true and γ is nothing, sets γ to the theoretically optimal 2.38 / sqrt(2 * dim). If false, sets γ to Uniform(0.8, 1.2). Defaults to true.\n\nExample\n\njulia> setup_de_update(ld; β = Normal(0.0, 0.01))\n\nSee also setup_snooker_update, setup_subspace_sampling.\n\n\n\n\n\n","category":"function"},{"location":"#DEMetropolis.setup_snooker_update","page":"DEMetropolis Documentation","title":"DEMetropolis.setup_snooker_update","text":"Set up a Snooker update step.\n\nSee doi.org/10.1007/s11222-008-9104-9 for more information.\n\nKeyword Arguments\n\nγ: The scaling factor for the projection. Can be a Real, a Distributions.UnivariateDistribution, or nothing. If nothing, it defaults based on deterministic_γ.\ndeterministic_γ: If true and γ is nothing, sets γ to the theoretically optimal 2.38 / sqrt(2). If false, sets γ to Uniform(0.8, 1.2). Defaults to true.\n\nExample\n\njulia> setup_snooker_update(γ = Uniform(0.1, 2.0))\n\nSee also setup_de_update, setup_subspace_sampling.\n\n\n\n\n\n","category":"function"},{"location":"#DEMetropolis.setup_subspace_sampling","page":"DEMetropolis Documentation","title":"DEMetropolis.setup_subspace_sampling","text":"Set up a Subspace Sampling (DREAM-like) update step.\n\nSee doi.org/10.1515/IJNSNS.2009.10.3.273 for more information.\n\nKeyword Arguments\n\nγ: Fixed scaling factor for the difference vector sum. If nothing (default), uses 2.38 / sqrt(2 * δ * d) where d is the number of updated dimensions. If a Real is provided, uses that fixed value.\ncr: Crossover probability. Can be a Real (fixed probability), nothing (adaptive probability using n_cr values), or a Distributions.UnivariateDistribution. Defaults to nothing.\nn_cr: Number of crossover probabilities to adapt between if cr is nothing. Defaults to 3.\nδ: Number of difference vectors to add. Can be an Integer or a Distributions.DiscreteUnivariateDistribution. Defaults to DiscreteUniform(1, 3).\nϵ: Distribution for small noise added to the proposal in the selected subspace. Defaults to Uniform(-1e-4, 1e-4).\ne: Distribution for multiplicative noise (e + 1) applied to the difference vector sum. Defaults to Normal(0.0, 1e-2).\n\nExample\n\njulia> setup_subspace_sampling(cr = Beta(1, 2))\n\nSee also setup_de_update, setup_snooker_update.\n\n\n\n\n\n","category":"function"},{"location":"#Stopping-Criteria","page":"DEMetropolis Documentation","title":"Stopping Criteria","text":"","category":"section"},{"location":"#DEMetropolis.R̂_stopping_criteria","page":"DEMetropolis Documentation","title":"DEMetropolis.R̂_stopping_criteria","text":"Create a stopping criterion based on the rank Gelman-Rubin diagnostic (R̂). Sampling stops when the R̂ value for all parameters is below maximum_R̂.\n\nArguments\n\nmaximum_R̂: The maximum acceptable R̂ value. Defaults to 1.2.\n\nSee also MCMCDiagnosticTools.rhat.\n\n\n\n\n\n","category":"type"},{"location":"#Diagnostics-Checks-with-Resampling","page":"DEMetropolis Documentation","title":"Diagnostics Checks with Resampling","text":"","category":"section"},{"location":"#DEMetropolis.ld_check","page":"DEMetropolis Documentation","title":"DEMetropolis.ld_check","text":"Create a diagnostic check that identifies outlier chains based on their mean log-density (of the last 50% of the chain) during burn-in/warm-up. Outlier chains (those with mean log-density below Q1 - 2*IQR) are reset to the state of the chain with the highest mean log-density.\n\nSee: Vrugt 2009 doi.org/10.1515/IJNSNS.2009.10.3.273\n\nSee also acceptance_check.\n\n\n\n\n\n","category":"type"},{"location":"#DEMetropolis.acceptance_check","page":"DEMetropolis Documentation","title":"DEMetropolis.acceptance_check","text":"Create a diagnostic check that identifies poorly mixing chains based on their acceptance rate (of the last 50% of the chain) during burn-in/warm-up. Chains with acceptance rates below min_acceptance and significantly lower than others (based on log-acceptance rate IQR) are reset to the state of the chain closest to the target_acceptance rate.\n\nArguments\n\nmin_acceptance: The minimum acceptable acceptance rate. Defaults to 0.1.\ntarget_acceptance: The target acceptance rate used to select the best chain for resetting outliers. Defaults to 0.24.\n\nSee also ld_check.\n\n\n\n\n\n","category":"type"},{"location":"#Index","page":"DEMetropolis Documentation","title":"Index","text":"","category":"section"},{"location":"","page":"DEMetropolis Documentation","title":"DEMetropolis Documentation","text":"","category":"page"},{"location":"tutorial/#Sampling-from-multimodal-distributions","page":"Sampling from multimodal distributions","title":"Sampling from multimodal distributions","text":"","category":"section"},{"location":"tutorial/","page":"Sampling from multimodal distributions","title":"Sampling from multimodal distributions","text":"WIP","category":"page"},{"location":"tutorial/#Multimodal-Distributions","page":"Sampling from multimodal distributions","title":"Multimodal Distributions","text":"","category":"section"},{"location":"tutorial/#Sampling-with-MCMC-and-HMC","page":"Sampling from multimodal distributions","title":"Sampling with MCMC and HMC","text":"","category":"section"},{"location":"tutorial/#Using-DREAM","page":"Sampling from multimodal distributions","title":"Using DREAM","text":"","category":"section"},{"location":"tutorial/#Custom-Scheme","page":"Sampling from multimodal distributions","title":"Custom Scheme","text":"","category":"section"}]
}
