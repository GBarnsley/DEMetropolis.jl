"""
Create a diagnostic check that identifies outlier chains based on their mean log-density (of the last 50% of the chain) during burn-in/warm-up.
Outlier chains (those with mean log-density below Q1 - 2*IQR) are reset to the state of the chain with the highest mean log-density.

See: Vrugt 2009 doi.org/10.1515/IJNSNS.2009.10.3.273

See also [`DifferentialEvolutionDiagnosticAcceptance`](@ref).
"""
function log_density_diagnostic_check(
    state::AbstractDifferentialEvolutionState,
    samples::Vector{DifferentialEvolutionSample{V, VV}},
    diagnostic_check::DifferentialEvolutionDiagnosticLogDensity;
    kwargs...
) where {T<:Real, V<:AbstractVector{T}, VV<:AbstractVector{V}}

    #calculate IQR of log densities of the last 50%
    ld_means = mean(ld_to_array(samples[(length(samples) ÷ 2 + 1):end]), dims = 1)[1, :]
    q₁ = quantile(ld_means, 0.25)

    outliers = findall(ld_means .< q₁ - 2 * (quantile(ld_means, 0.75) - q₁))

    if length(outliers) > 0
        @warn string(length(outliers)) * " outlier chains detected, setting to best chain"
        #remove outliers
        best_chain = argmax(ld_means)

        x = copy(state.x)
        ld = copy(state.ld)

        ld[outliers] .= ld[best_chain]
        x[outliers] .= x[best_chain]
        return true, update_state(state; x = x, ld = ld)
    else
        return false, state
    end
end

"""
Create a diagnostic check that identifies poorly mixing chains based on their acceptance rate (of the last 50% of the chain) during burn-in/warm-up.
Chains with acceptance rates below `min_acceptance` and significantly lower than others (based on log-acceptance rate IQR) are reset to the state of the chain closest to the `target_acceptance` rate.

# Arguments
- `min_acceptance`: The minimum acceptable acceptance rate. Defaults to 0.1.
- `target_acceptance`: The target acceptance rate used to select the best chain for resetting outliers. Defaults to 0.24.

See also [`DifferentialEvolutionDiagnosticLogDensity`](@ref).
"""
function acceptance_diagnostic_check(
    state::AbstractDifferentialEvolutionState,
    samples::Vector{DifferentialEvolutionSample{V, VV}},
    diagnostic_check::DifferentialEvolutionDiagnosticAcceptance;
    min_acceptance::T = 0.1,
    target_acceptance::T = 0.24,
    kwargs...
) where {T<:Real, V<:AbstractVector{T}, VV<:AbstractVector{V}}

    #calculate average acceptance
    ld = ld_to_array(chains)
    p_acceptance = sum(diff(ld; dims = 1) .!= 0, dims = 1)[1, :] ./ (size(ld, 1) - 1)

    #IQR on a log level to be more sensitive
    lp_acceptance = log.(p_acceptance)

    q₁ = quantile(lp_acceptance, 0.25)
    outliers = findall((lp_acceptance .< (q₁ - 2 * (quantile(lp_acceptance, 0.75) - q₁))) .&
                       (p_acceptance .< min_acceptance))

    if length(outliers) > 0
        @warn string(length(outliers)) *
              " poorly mixing chain chains detected, setting to best chain"
        #remove outliers
        best_chain = [argmin(abs.(p_acceptance .- target_acceptance))]

        x = copy(state.x)
        ld = copy(state.ld)

        ld[outliers] .= ld[best_chain]
        x[outliers] .= x[best_chain]
        return true, update_state(state; x = x, ld = ld)
    else
        return false, state
    end
end

#sample wrapper with diagnostics
function sample(
        rng::Random.AbstractRNG=Random.default_rng(),
        model::AbstractModel,
        sampler::AbstractSampler,
        parallel::AbstractMCMCEnsemble,
        N::Integer,
        nchains::Integer;
        kwargs...,
    )

hmm, seems tricky to implement and probably not necessary

end
